use serde::{Deserialize, Serialize};

use crate::types::{
    AssistantAudio, AssistantContent, AssistantFunctionCall, AssistantToolCall, Content, ImageUrl,
    UserContent, UserContentPart,
};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(tag = "role")]
#[serde(rename_all = "lowercase")]
pub enum ChatMessage {
    Developer {
        /// The contents of the developer message.
        content: Content,
        /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
        #[serde(skip_serializing_if = "Option::is_none")]
        name: Option<String>,
    },
    System {
        /// The contents of the developer message.
        content: Content,
        /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
        #[serde(skip_serializing_if = "Option::is_none")]
        name: Option<String>,
    },
    User {
        /// The contents of the user message.
        content: UserContent,
        /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
        #[serde(skip_serializing_if = "Option::is_none")]
        name: Option<String>,
    },
    Assistant {
        /// The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
        #[serde(skip_serializing_if = "Option::is_none")]
        content: Option<AssistantContent>,

        /// The refusal message by the assistant.
        #[serde(skip_serializing_if = "Option::is_none")]
        refusal: Option<String>,

        /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
        #[serde(skip_serializing_if = "Option::is_none")]
        name: Option<String>,

        /// Data about a previous audio response from the model. [Learn more](https://platform.openai.com/docs/guides/audio).
        #[serde(skip_serializing_if = "Option::is_none")]
        audio: Option<AssistantAudio>,

        /// The tool calls generated by the model, such as function calls.
        #[serde(skip_serializing_if = "Option::is_none")]
        tool_calls: Option<Vec<AssistantToolCall>>,

        /// Deprecated and replaced by tool_calls. The name and arguments of a function that should be called, as generated by the model.
        #[deprecated]
        #[serde(skip_serializing_if = "Option::is_none")]
        function_call: Option<AssistantFunctionCall>,
    },
    Tool {
        /// The contents of the tool message.
        content: Content,

        /// Tool call that this message is responding to.
        tool_call_id: String,
    },
}

impl ChatMessage {
    pub fn name(self, name: impl Into<String>) -> Self {
        match self {
            ChatMessage::Developer { content, name: _ } => ChatMessage::Developer {
                content,
                name: Some(name.into()),
            },
            ChatMessage::System { content, name: _ } => ChatMessage::System {
                content,
                name: Some(name.into()),
            },
            ChatMessage::User { content, name: _ } => ChatMessage::User {
                content,
                name: Some(name.into()),
            },
            _ => self,
        }
    }
}

impl ChatMessage {
    pub fn system(content: impl Into<Content>) -> Self {
        Self::System {
            content: content.into(),
            name: None,
        }
    }
    pub fn developer(content: impl Into<Content>) -> Self {
        Self::Developer {
            content: content.into(),
            name: None,
        }
    }

    pub fn user(content: impl Into<String>) -> Self {
        Self::User {
            content: UserContent::Text(content.into()),
            name: None,
        }
    }

    pub fn user_image(image_url: impl Into<ImageUrl>) -> Self {
        Self::User {
            content: UserContent::Array(vec![UserContentPart::image(image_url)]),
            name: None,
        }
    }

    pub fn user_image_with_text(text: impl Into<String>, image_url: impl Into<ImageUrl>) -> Self {
        Self::user_parts(vec![
            UserContentPart::text(text),
            UserContentPart::image(image_url),
        ])
    }

    pub fn user_parts(parts: Vec<UserContentPart>) -> Self {
        Self::User {
            content: UserContent::Array(parts),
            name: None,
        }
    }

    pub fn assistant(content: impl Into<AssistantContent>) -> Self {
        Self::Assistant {
            content: Some(content.into()),
            refusal: None,
            name: None,
            audio: None,
            tool_calls: None,
            function_call: None,
        }
    }

    pub fn tool(content: impl Into<Content>, tool_call_id: impl Into<String>) -> Self {
        Self::Tool {
            content: content.into(),
            tool_call_id: tool_call_id.into(),
        }
    }
}

// impl TryInto<ChatCompletionRequestMessage> for ChatMessage {
//     type Error = Error;
//     fn try_into(self) -> Result<ChatCompletionRequestMessage, Self::Error> {
//         Ok(match self {
//             ChatMessage::Developer(message_content) => {
//                 ChatCompletionRequestDeveloperMessageBuilder::default()
//                     .content(message_content)
//                     .build()?
//                     .into()
//             }
//             ChatMessage::System(message_content) => {
//                 ChatCompletionRequestSystemMessageBuilder::default()
//                     .content(message_content)
//                     .build()?
//                     .into()
//             }
//             ChatMessage::User(message_content) => {
//                 ChatCompletionRequestUserMessageBuilder::default()
//                     .content(message_content)
//                     .build()?
//                     .into()
//             }
//             ChatMessage::Tool {
//                 message_content,
//                 tool_call_id,
//             } => ChatCompletionRequestToolMessageBuilder::default()
//                 .content(message_content)
//                 .tool_call_id(tool_call_id)
//                 .build()?
//                 .into(),
//             ChatMessage::Assistant {
//                 message_content,
//                 refusal,
//                 audio,
//             } => match message_content {
//                 Some(message_content) => {
//                     let assistant_content: AssistantContent = message_content.try_into()?;
//                     ChatCompletionRequestAssistantMessageBuilder::default()
//                         .content(assistant_content)
//                         .build()?
//                         .into()
//                 }
//                 None => todo!(),
//             },
//         })
//     }
// }
